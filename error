 FATAL EXCEPTION: main
                                                                                                    Process: com.android.privacyview, PID: 5341
                                                                                                    java.lang.NullPointerException: Attempt to invoke virtual method 'void org.tensorflow.lite.Interpreter.run(java.lang.Object, java.lang.Object)' on a null object reference
                                                                                                    	at com.android.privacyview.utils.FaceRecognitionHelper.generateEmbedding(FaceRecognitionHelper.java:64)
                                                                                                    	at com.android.privacyview.ui.FaceRecognitionActivity.lambda$bindCameraUseCases$1$com-android-privacyview-ui-FaceRecognitionActivity(FaceRecognitionActivity.java:123)
                                                                                                    	at com.android.privacyview.ui.FaceRecognitionActivity$$ExternalSyntheticLambda0.onSuccess(Unknown Source:6)
                                                                                                    	at com.google.android.gms.tasks.zzm.run(com.google.android.gms:play-services-tasks@@18.1.0:1)
                                                                                                    	at android.os.Handler.handleCallback(Handler.java:958)
                                                                                                    	at android.os.Handler.dispatchMessage(Handler.java:99)
                                                                                                    	at android.os.Looper.loopOnce(Looper.java:230)


public class FaceRecognitionHelper {
    private static final String MODEL_FILE = "facenet_model.tflite";
    private static final int INPUT_SIZE = 160; // The input size the model expects
    private Context context;
    private Interpreter interpreter;
    private Map<String, float[]> faceEmbeddings;

    public FaceRecognitionHelper(Context context) {
        this.context = context;
        faceEmbeddings = new HashMap<>();
        initializeInterpreter();
    }

    private void initializeInterpreter() {
        try {
            Interpreter.Options options = new Interpreter.Options();
            options.setNumThreads(4); // Adjust based on your needs
            
            // Load model from assets
            ByteBuffer model = loadModelFile();
            interpreter = new Interpreter(model, options);
        } catch (IOException e) {
            Log.e("FaceRecognitionHelper", "Error initializing TFLite interpreter", e);
        }
    }

    private ByteBuffer loadModelFile() throws IOException {
        String modelPath = MODEL_FILE;
        AssetFileDescriptor fileDescriptor = context.getAssets().openFd(modelPath);
        FileInputStream inputStream = new FileInputStream(fileDescriptor.getFileDescriptor());
        FileChannel fileChannel = inputStream.getChannel();
        long startOffset = fileDescriptor.getStartOffset();
        long declaredLength = fileDescriptor.getDeclaredLength();
        
        ByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength);
        inputStream.close();
        return buffer;
    }

    public float[] generateEmbedding(Bitmap faceBitmap) {
        if (interpreter == null) {
            Log.e("FaceRecognitionHelper", "TFLite interpreter is null");
            return null;
        }

        // Preprocess the bitmap to match model input requirements
        Bitmap scaledBitmap = Bitmap.createScaledBitmap(faceBitmap, INPUT_SIZE, INPUT_SIZE, true);
        
        // Convert bitmap to float array
        ByteBuffer imgData = ByteBuffer.allocateDirect(INPUT_SIZE * INPUT_SIZE * 3 * 4); // 4 bytes per float
        imgData.order(ByteOrder.nativeOrder());
        
        int[] pixels = new int[INPUT_SIZE * INPUT_SIZE];
        scaledBitmap.getPixels(pixels, 0, INPUT_SIZE, 0, 0, INPUT_SIZE, INPUT_SIZE);
        
        // Normalize pixel values to [-1, 1]
        for (int pixel : pixels) {
            float r = ((pixel >> 16) & 0xFF) / 127.5f - 1;
            float g = ((pixel >> 8) & 0xFF) / 127.5f - 1;
            float b = (pixel & 0xFF) / 127.5f - 1;
            
            imgData.putFloat(r);
            imgData.putFloat(g);
            imgData.putFloat(b);
        }

        // Output array for the model
        float[][] embeddings = new float[1][512]; // Adjust size based on your model's output
        
        try {
            // Run inference
            Object[] inputArray = {imgData.rewind()};
            Map<Integer, Object> outputMap = new HashMap<>();
            outputMap.put(0, embeddings);
            
            interpreter.runForMultipleInputsOutputs(inputArray, outputMap);
            
            return embeddings[0];
        } catch (Exception e) {
            Log.e("FaceRecognitionHelper", "Error running model inference", e);
            return null;
        } finally {
            if (scaledBitmap != faceBitmap) {
                scaledBitmap.recycle();
            }
        }
    }

    public void loadFaceEmbeddings() {
        // Load stored face embeddings from storage
        // This is where you would load previously stored face embeddings
        // For now, we'll just add a sample embedding
        try {
            // Load embeddings from shared preferences or file storage
            SharedPreferences prefs = context.getSharedPreferences("FaceEmbeddings", Context.MODE_PRIVATE);
            // Implementation depends on how you store your embeddings
        } catch (Exception e) {
            Log.e("FaceRecognitionHelper", "Error loading face embeddings", e);
        }
    }

    public String recognizeFace(float[] newEmbedding) {
        if (newEmbedding == null) return "Unknown";
        
        String closestMatch = "Unknown";
        float minDistance = Float.MAX_VALUE;
        
        for (Map.Entry<String, float[]> entry : faceEmbeddings.entrySet()) {
            float distance = calculateDistance(newEmbedding, entry.getValue());
            if (distance < minDistance) {
                minDistance = distance;
                closestMatch = entry.getKey();
            }
        }
        
        // You might want to set a threshold for recognition
        return minDistance < 1.0f ? closestMatch : "Unknown";
    }

    private float calculateDistance(float[] emb1, float[] emb2) {
        float sum = 0;
        for (int i = 0; i < emb1.length; i++) {
            float diff = emb1[i] - emb2[i];
            sum += diff * diff;
        }
        return (float) Math.sqrt(sum);
    }
0000
public class FaceRecognitionHelper {
    private static final String MODEL_FILE = "facenet_model.tflite";
    private static final int INPUT_SIZE = 160;
    private static final String SHARED_PREFS_NAME = "FaceEmbeddings";
    private static final String EMBEDDING_PREFIX = "face_embedding_";
    private static final String NAME_LIST_KEY = "registered_faces";
    private static final float RECOGNITION_THRESHOLD = 0.8f;

    private Context context;
    private Interpreter interpreter;
    private Map<String, float[]> faceEmbeddings;
    private Gson gson;

    public FaceRecognitionHelper(Context context) {
        this.context = context;
        this.faceEmbeddings = new HashMap<>();
        this.gson = new Gson();
        initializeInterpreter();
        loadFaceEmbeddings();
    }

    public boolean addNewFace(Bitmap faceBitmap, String personName) {
        try {
            // Generate embedding for the new face
            float[] newEmbedding = generateEmbedding(faceBitmap);
            if (newEmbedding == null) {
                Log.e("FaceRecognitionHelper", "Failed to generate embedding for new face");
                return false;
            }

            // Check if this face is too similar to any existing face
            for (Map.Entry<String, float[]> entry : faceEmbeddings.entrySet()) {
                float distance = calculateDistance(newEmbedding, entry.getValue());
                if (distance < RECOGNITION_THRESHOLD) {
                    Log.w("FaceRecognitionHelper", "Face too similar to existing face: " + entry.getKey());
                    return false;
                }
            }

            // Add the new embedding to the map
            faceEmbeddings.put(personName, newEmbedding);

            // Save to persistent storage
            return saveFaceEmbeddings();

        } catch (Exception e) {
            Log.e("FaceRecognitionHelper", "Error adding new face", e);
            return false;
        }
    }

    private boolean saveFaceEmbeddings() {
        try {
            SharedPreferences prefs = context.getSharedPreferences(SHARED_PREFS_NAME, Context.MODE_PRIVATE);
            SharedPreferences.Editor editor = prefs.edit();

            // Save the list of names
            Set<String> nameSet = new HashSet<>(faceEmbeddings.keySet());
            editor.putStringSet(NAME_LIST_KEY, nameSet);

            // Save each embedding
            for (Map.Entry<String, float[]> entry : faceEmbeddings.entrySet()) {
                String name = entry.getKey();
                float[] embedding = entry.getValue();
                String embeddingJson = gson.toJson(embedding);
                editor.putString(EMBEDDING_PREFIX + name, embeddingJson);
            }

            return editor.commit();
        } catch (Exception e) {
            Log.e("FaceRecognitionHelper", "Error saving face embeddings", e);
            return false;
        }
    }

    public void loadFaceEmbeddings() {
        try {
            SharedPreferences prefs = context.getSharedPreferences(SHARED_PREFS_NAME, Context.MODE_PRIVATE);
            Set<String> nameSet = prefs.getStringSet(NAME_LIST_KEY, new HashSet<>());

            faceEmbeddings.clear();
            for (String name : nameSet) {
                String embeddingJson = prefs.getString(EMBEDDING_PREFIX + name, null);
                if (embeddingJson != null) {
                    float[] embedding = gson.fromJson(embeddingJson, float[].class);
                    faceEmbeddings.put(name, embedding);
                }
            }

            Log.d("FaceRecognitionHelper", "Loaded " + faceEmbeddings.size() + " face embeddings");
        } catch (Exception e) {
            Log.e("FaceRecognitionHelper", "Error loading face embeddings", e);
        }
    }

    public boolean removeFace(String personName) {
        try {
            if (!faceEmbeddings.containsKey(personName)) {
                return false;
            }

            faceEmbeddings.remove(personName);
            
            SharedPreferences prefs = context.getSharedPreferences(SHARED_PREFS_NAME, Context.MODE_PRIVATE);
            SharedPreferences.Editor editor = prefs.edit();
            
            // Remove the embedding
            editor.remove(EMBEDDING_PREFIX + personName);
            
            // Update the name set
            Set<String> nameSet = new HashSet<>(faceEmbeddings.keySet());
            editor.putStringSet(NAME_LIST_KEY, nameSet);
            
            return editor.commit();
        } catch (Exception e) {
            Log.e("FaceRecognitionHelper", "Error removing face", e);
            return false;
        }
    }

    public List<String> getRegisteredFaces() {
        return new ArrayList<>(faceEmbeddings.keySet());
    }

    public boolean hasFaceRegistered(String personName) {
        return faceEmbeddings.containsKey(personName);
    }

    // ... (keep all previous methods: initializeInterpreter, loadModelFile, generateEmbedding, etc.)

    // Updated recognition method with threshold
    public String recognizeFace(float[] newEmbedding) {
        if (newEmbedding == null) return "Unknown";
        
        String closestMatch = "Unknown";
        float minDistance = Float.MAX_VALUE;
        
        for (Map.Entry<String, float[]> entry : faceEmbeddings.entrySet()) {
            float distance = calculateDistance(newEmbedding, entry.getValue());
            if (distance < minDistance) {
                minDistance = distance;
                closestMatch = entry.getKey();
            }
        }
        
        return minDistance < RECOGNITION_THRESHOLD ? closestMatch : "Unknown";
    }
}