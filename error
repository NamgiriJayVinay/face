





FATAL EXCEPTION: main
                                                                                                    Process: com.android.privacyview, PID: 9602
                                                                                                    java.lang.NullPointerException: Attempt to invoke virtual method 'void android.graphics.Paint.set(android.graphics.Paint)' on a null object reference
                                                                                                    	at android.graphics.BaseRecordingCanvas.drawText(BaseRecordingCanvas.java:487)
                                                                                                    	at com.android.privacyview.utils.FaceBoxOverlay.onDraw(FaceBoxOverlay.java:104)
                                                                                                    	at android.view.View.draw(View.java:25194)
                                                                                                    	at android.view.View.updateDisplayListIfDirty(View.java:24053)
                                                                                                    	at android.view.ViewGroup.recreateChildDisplayList(ViewGroup.java:4788)
                                                                                                    	at android.view.ViewGroup.dispatchGetDisplayList(ViewGroup.java:4760)
                                                                                                    	at android.view.View.updateDisplayListIfDirty(View.java:23999)
                                                                                                    	at android.view.ViewGroup.recreateChildDisplayList(ViewGroup.java:4788)
                                                                                                    	at android.view.ViewGroup.dispatchGetDisplayList(ViewGroup.java:4760)
                                                                                                    	at android.view.View.updateDisplayListIfDirty(View.java:23999)
                                                                                                    	at android.view.ViewGroup.recreateChildDisplayList(ViewGroup.java:4788)
                                                                                                    	at android.view.ViewGroup.dispatchGetDisplayList(ViewGroup.java:4760)
                                                                                                    	at android.view.View.updateDisplayListIfDirty(View.java:23999)
                                                                                                    	at android.view.ViewGroup.recreateChildDisplayList(ViewGroup.java:4788)
                                                                                                    	at android.view.ViewGroup.dispatchGetDisplayList(ViewGroup.java:4760)
                                                                                                    	at android.view.View.updateDisplayListIfDirty(View.java:23999)
                                                                                                    	at android.view.ViewGroup.recreateChildDisplayList(ViewGroup.java:4788)
                                                                                                    	at android.view.ViewGroup.dispatchGetDisplayList(ViewGroup.java:4760)





public class FaceBoxOverlay extends View {
    private static final float BOX_STROKE_WIDTH = 5.0f;
    private static final float TEXT_SIZE = 40.0f;
    private static final int TEXT_PADDING = 10;

    private Paint boxPaint;
    private Paint textPaint;
    private Paint backgroundPaint;
    
    private Rect faceBox;
    private String personName;
    private float scaleX = 1.0f;
    private float scaleY = 1.0f;
    private int previewWidth;
    private int previewHeight;
    private boolean isFrontCamera = true;

    public FaceBoxOverlay(Context context) {
        super(context);
        init();
    }

    public FaceBoxOverlay(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public FaceBoxOverlay(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    private void init() {
        // Initialize box paint
        boxPaint = new Paint();
        boxPaint.setColor(Color.GREEN);
        boxPaint.setStyle(Paint.Style.STROKE);
        boxPaint.setStrokeWidth(BOX_STROKE_WIDTH);

        // Initialize text paint
        textPaint = new Paint();
        textPaint.setColor(Color.WHITE);
        textPaint.setTextSize(TEXT_SIZE);
        textPaint.setStyle(Paint.Style.FILL);
        textPaint.setAntiAlias(true);

        // Initialize background paint for text
        backgroundPaint = new Paint();
        backgroundPaint.setColor(Color.argb(128, 0, 0, 0));
        backgroundPaint.setStyle(Paint.Style.FILL);
    }

    public void setPreviewSize(int width, int height) {
        previewWidth = width;
        previewHeight = height;
        calculateScale();
    }

    private void calculateScale() {
        if (previewWidth > 0 && previewHeight > 0) {
            scaleX = (float) getWidth() / previewWidth;
            scaleY = (float) getHeight() / previewHeight;
        }
    }

    public void setIsFrontCamera(boolean isFront) {
        isFrontCamera = isFront;
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        calculateScale();
    }

    public void updateFaceBox(Rect box, String name) {
        if (box == null) {
            faceBox = null;
            personName = null;
        } else {
            faceBox = new Rect(box);
            personName = name;
        }
        postInvalidate();
    }

    public void clearFaceBox() {
        faceBox = null;
        personName = null;
        postInvalidate();
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (faceBox == null || personName == null) {
            return;
        }

        // Scale the face box to match the preview size
        Rect scaledBox = new Rect(
            (int) (faceBox.left * scaleX),
            (int) (faceBox.top * scaleY),
            (int) (faceBox.right * scaleX),
            (int) (faceBox.bottom * scaleY)
        );

        // If using front camera, mirror the box horizontally
        if (isFrontCamera) {
            int width = getWidth();
            int left = scaledBox.left;
            scaledBox.left = width - scaledBox.right;
            scaledBox.right = width - left;
        }

        // Draw the face box
        canvas.drawRect(scaledBox, boxPaint);

        // Draw the name
        if (personName != null && !personName.isEmpty()) {
            // Measure text for background
            Rect textBounds = new Rect();
            textPaint.getTextBounds(personName, 0, personName.length(), textBounds);
            
            // Calculate text position
            float textX = scaledBox.left;
            float textY = scaledBox.top - TEXT_PADDING;
            
            // Draw text background
            float backgroundLeft = textX - TEXT_PADDING;
            float backgroundRight = textX + textBounds.width() + TEXT_PADDING;
            float backgroundTop = textY - textBounds.height() - TEXT_PADDING;
            float backgroundBottom = textY + TEXT_PADDING;
            
            canvas.drawRect(
                backgroundLeft,
                backgroundTop,
                backgroundRight,
                backgroundBottom,
                backgroundPaint
            );

            // Draw the name text
            canvas.drawText(personName, textX, textY, textPaint);
        }
    }
}













public class FaceRecognitionHelper {
    private static final String MODEL_FILE = "facenet_model.tflite";
    private static final int INPUT_SIZE = 160; // The input size the model expects
    private Context context;
    private Interpreter interpreter;
    private Map<String, float[]> faceEmbeddings;

    public FaceRecognitionHelper(Context context) {
        this.context = context;
        faceEmbeddings = new HashMap<>();
        initializeInterpreter();
    }

    private void initializeInterpreter() {
        try {
            Interpreter.Options options = new Interpreter.Options();
            options.setNumThreads(4); // Adjust based on your needs
            
            // Load model from assets
            ByteBuffer model = loadModelFile();
            interpreter = new Interpreter(model, options);
        } catch (IOException e) {
            Log.e("FaceRecognitionHelper", "Error initializing TFLite interpreter", e);
        }
    }

    private ByteBuffer loadModelFile() throws IOException {
        String modelPath = MODEL_FILE;
        AssetFileDescriptor fileDescriptor = context.getAssets().openFd(modelPath);
        FileInputStream inputStream = new FileInputStream(fileDescriptor.getFileDescriptor());
        FileChannel fileChannel = inputStream.getChannel();
        long startOffset = fileDescriptor.getStartOffset();
        long declaredLength = fileDescriptor.getDeclaredLength();
        
        ByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength);
        inputStream.close();
        return buffer;
    }

    public float[] generateEmbedding(Bitmap faceBitmap) {
        if (interpreter == null) {
            Log.e("FaceRecognitionHelper", "TFLite interpreter is null");
            return null;
        }

        // Preprocess the bitmap to match model input requirements
        Bitmap scaledBitmap = Bitmap.createScaledBitmap(faceBitmap, INPUT_SIZE, INPUT_SIZE, true);
        
        // Convert bitmap to float array
        ByteBuffer imgData = ByteBuffer.allocateDirect(INPUT_SIZE * INPUT_SIZE * 3 * 4); // 4 bytes per float
        imgData.order(ByteOrder.nativeOrder());
        
        int[] pixels = new int[INPUT_SIZE * INPUT_SIZE];
        scaledBitmap.getPixels(pixels, 0, INPUT_SIZE, 0, 0, INPUT_SIZE, INPUT_SIZE);
        
        // Normalize pixel values to [-1, 1]
        for (int pixel : pixels) {
            float r = ((pixel >> 16) & 0xFF) / 127.5f - 1;
            float g = ((pixel >> 8) & 0xFF) / 127.5f - 1;
            float b = (pixel & 0xFF) / 127.5f - 1;
            
            imgData.putFloat(r);
            imgData.putFloat(g);
            imgData.putFloat(b);
        }

        // Output array for the model
        float[][] embeddings = new float[1][512]; // Adjust size based on your model's output
        
        try {
            // Run inference
            Object[] inputArray = {imgData.rewind()};
            Map<Integer, Object> outputMap = new HashMap<>();
            outputMap.put(0, embeddings);
            
            interpreter.runForMultipleInputsOutputs(inputArray, outputMap);
            
            return embeddings[0];
        } catch (Exception e) {
            Log.e("FaceRecognitionHelper", "Error running model inference", e);
            return null;
        } finally {
            if (scaledBitmap != faceBitmap) {
                scaledBitmap.recycle();
            }
        }
    }

    public void loadFaceEmbeddings() {
        // Load stored face embeddings from storage
        // This is where you would load previously stored face embeddings
        // For now, we'll just add a sample embedding
        try {
            // Load embeddings from shared preferences or file storage
            SharedPreferences prefs = context.getSharedPreferences("FaceEmbeddings", Context.MODE_PRIVATE);
            // Implementation depends on how you store your embeddings
        } catch (Exception e) {
            Log.e("FaceRecognitionHelper", "Error loading face embeddings", e);
        }
    }

    public String recognizeFace(float[] newEmbedding) {
        if (newEmbedding == null) return "Unknown";
        
        String closestMatch = "Unknown";
        float minDistance = Float.MAX_VALUE;
        
        for (Map.Entry<String, float[]> entry : faceEmbeddings.entrySet()) {
            float distance = calculateDistance(newEmbedding, entry.getValue());
            if (distance < minDistance) {
                minDistance = distance;
                closestMatch = entry.getKey();
            }
        }
        
        // You might want to set a threshold for recognition
        return minDistance < 1.0f ? closestMatch : "Unknown";
    }

    private float calculateDistance(float[] emb1, float[] emb2) {
        float sum = 0;
        for (int i = 0; i < emb1.length; i++) {
            float diff = emb1[i] - emb2[i];
            sum += diff * diff;
        }
        return (float) Math.sqrt(sum);
    }
0000
public class FaceRecognitionHelper {
    private static final String MODEL_FILE = "facenet_model.tflite";
    private static final int INPUT_SIZE = 160;
    private static final String SHARED_PREFS_NAME = "FaceEmbeddings";
    private static final String EMBEDDING_PREFIX = "face_embedding_";
    private static final String NAME_LIST_KEY = "registered_faces";
    private static final float RECOGNITION_THRESHOLD = 0.8f;

    private Context context;
    private Interpreter interpreter;
    private Map<String, float[]> faceEmbeddings;
    private Gson gson;

    public FaceRecognitionHelper(Context context) {
        this.context = context;
        this.faceEmbeddings = new HashMap<>();
        this.gson = new Gson();
        initializeInterpreter();
        loadFaceEmbeddings();
    }

    public boolean addNewFace(Bitmap faceBitmap, String personName) {
        try {
            // Generate embedding for the new face
            float[] newEmbedding = generateEmbedding(faceBitmap);
            if (newEmbedding == null) {
                Log.e("FaceRecognitionHelper", "Failed to generate embedding for new face");
                return false;
            }

            // Check if this face is too similar to any existing face
            for (Map.Entry<String, float[]> entry : faceEmbeddings.entrySet()) {
                float distance = calculateDistance(newEmbedding, entry.getValue());
                if (distance < RECOGNITION_THRESHOLD) {
                    Log.w("FaceRecognitionHelper", "Face too similar to existing face: " + entry.getKey());
                    return false;
                }
            }

            // Add the new embedding to the map
            faceEmbeddings.put(personName, newEmbedding);

            // Save to persistent storage
            return saveFaceEmbeddings();

        } catch (Exception e) {
            Log.e("FaceRecognitionHelper", "Error adding new face", e);
            return false;
        }
    }

    private boolean saveFaceEmbeddings() {
        try {
            SharedPreferences prefs = context.getSharedPreferences(SHARED_PREFS_NAME, Context.MODE_PRIVATE);
            SharedPreferences.Editor editor = prefs.edit();

            // Save the list of names
            Set<String> nameSet = new HashSet<>(faceEmbeddings.keySet());
            editor.putStringSet(NAME_LIST_KEY, nameSet);

            // Save each embedding
            for (Map.Entry<String, float[]> entry : faceEmbeddings.entrySet()) {
                String name = entry.getKey();
                float[] embedding = entry.getValue();
                String embeddingJson = gson.toJson(embedding);
                editor.putString(EMBEDDING_PREFIX + name, embeddingJson);
            }

            return editor.commit();
        } catch (Exception e) {
            Log.e("FaceRecognitionHelper", "Error saving face embeddings", e);
            return false;
        }
    }

    public void loadFaceEmbeddings() {
        try {
            SharedPreferences prefs = context.getSharedPreferences(SHARED_PREFS_NAME, Context.MODE_PRIVATE);
            Set<String> nameSet = prefs.getStringSet(NAME_LIST_KEY, new HashSet<>());

            faceEmbeddings.clear();
            for (String name : nameSet) {
                String embeddingJson = prefs.getString(EMBEDDING_PREFIX + name, null);
                if (embeddingJson != null) {
                    float[] embedding = gson.fromJson(embeddingJson, float[].class);
                    faceEmbeddings.put(name, embedding);
                }
            }

            Log.d("FaceRecognitionHelper", "Loaded " + faceEmbeddings.size() + " face embeddings");
        } catch (Exception e) {
            Log.e("FaceRecognitionHelper", "Error loading face embeddings", e);
        }
    }

    public boolean removeFace(String personName) {
        try {
            if (!faceEmbeddings.containsKey(personName)) {
                return false;
            }

            faceEmbeddings.remove(personName);
            
            SharedPreferences prefs = context.getSharedPreferences(SHARED_PREFS_NAME, Context.MODE_PRIVATE);
            SharedPreferences.Editor editor = prefs.edit();
            
            // Remove the embedding
            editor.remove(EMBEDDING_PREFIX + personName);
            
            // Update the name set
            Set<String> nameSet = new HashSet<>(faceEmbeddings.keySet());
            editor.putStringSet(NAME_LIST_KEY, nameSet);
            
            return editor.commit();
        } catch (Exception e) {
            Log.e("FaceRecognitionHelper", "Error removing face", e);
            return false;
        }
    }

    public List<String> getRegisteredFaces() {
        return new ArrayList<>(faceEmbeddings.keySet());
    }

    public boolean hasFaceRegistered(String personName) {
        return faceEmbeddings.containsKey(personName);
    }

    // ... (keep all previous methods: initializeInterpreter, loadModelFile, generateEmbedding, etc.)

    // Updated recognition method with threshold
    public String recognizeFace(float[] newEmbedding) {
        if (newEmbedding == null) return "Unknown";
        
        String closestMatch = "Unknown";
        float minDistance = Float.MAX_VALUE;
        
        for (Map.Entry<String, float[]> entry : faceEmbeddings.entrySet()) {
            float distance = calculateDistance(newEmbedding, entry.getValue());
            if (distance < minDistance) {
                minDistance = distance;
                closestMatch = entry.getKey();
            }
        }
        
        return minDistance < RECOGNITION_THRESHOLD ? closestMatch : "Unknown";
    }
}
